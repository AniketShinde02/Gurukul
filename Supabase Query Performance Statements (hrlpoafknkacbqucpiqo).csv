query,rolname,calls,mean_time,min_time,max_time,total_time,rows_read,cache_hit_rate,prop_total_time,index_advisor_result
"SELECT wal->>$5 as type,
       wal->>$6 as schema,
       wal->>$7 as table,
       wal->>$8 as columns,
       wal->>$9 as record,
       wal->>$10 as old_record,
       wal->>$11 as commit_timestamp,
       subscription_ids,
       errors
FROM realtime.list_changes($1, $2, $3, $4)",supabase_admin,1110625,7.1778729654328,3.959648,4086.746442,7971925.16223407,1604,100.0000000000000000,93.52138206569333,"{""has_suggestion"":null,""startup_cost_before"":0.25,""startup_cost_after"":0.25,""total_cost_before"":27.75,""total_cost_after"":27.75,""index_statements"":[]}"
"SELECT wal->>$5 as type,
       wal->>$6 as schema,
       wal->>$7 as table,
       COALESCE(wal->>$8, $9) as columns,
       COALESCE(wal->>$10, $11) as record,
       COALESCE(wal->>$12, $13) as old_record,
       wal->>$14 as commit_timestamp,
       subscription_ids,
       errors
FROM realtime.list_changes($1, $2, $3, $4)",supabase_admin,23659,8.27833814070753,6.346818,3243.779587,195857.202070999,0,100.0000000000000000,2.2976678597000837,"{""has_suggestion"":null,""startup_cost_before"":0.25,""startup_cost_after"":0.25,""total_cost_before"":27.75,""total_cost_after"":27.75,""index_statements"":[]}"
"with sub_tables as (
        select
        rr.entity
        from
        pg_publication_tables pub,
        lateral (
        select
        format($7, pub.schemaname, pub.tablename)::regclass entity
        ) rr
        where
        pub.pubname = $1
        and pub.schemaname like (case $2 when $8 then $9 else $2 end)
        and pub.tablename like (case $3 when $10 then $11 else $3 end)
     )
     insert into realtime.subscription as x(
        subscription_id,
        entity,
        filters,
        claims
      )
      select
        $4::text::uuid,
        sub_tables.entity,
        $6,
        $5
      from
        sub_tables
        on conflict
        (subscription_id, entity, filters)
        do update set
        claims = excluded.claims,
        created_at = now()
      returning
         id",supabase_admin,10117,10.334145192646,0.08632,1146.803597,104550.546914,8021,99.9999585174983563,1.2265182429762376,null
"with f as (
      
-- CTE with sane arg_modes, arg_names, and arg_types.
-- All three are always of the same length.
-- All three include all args, including OUT and TABLE args.
with functions as (
  select
    *,
    -- proargmodes is null when all arg modes are IN
    coalesce(
      p.proargmodes,
      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_modes,
    -- proargnames is null when all args are unnamed
    coalesce(
      p.proargnames,
      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_names,
    -- proallargtypes is null when all arg modes are IN
    coalesce(p.proallargtypes, p.proargtypes) as arg_types,
    array_cat(
      array_fill($3, array[pronargs - pronargdefaults]),
      array_fill($4, array[pronargdefaults])) as arg_has_defaults
  from
    pg_proc as p
  where
    p.prokind = $5
)
select
  f.oid as id,
  n.nspname as schema,
  f.proname as name,
  l.lanname as language,
  case
    when l.lanname = $6 then $7
    else f.prosrc
  end as definition,
  case
    when l.lanname = $8 then f.prosrc
    else pg_get_functiondef(f.oid)
  end as complete_statement,
  coalesce(f_args.args, $9) as args,
  pg_get_function_arguments(f.oid) as argument_types,
  pg_get_function_identity_arguments(f.oid) as identity_argument_types,
  f.prorettype as return_type_id,
  pg_get_function_result(f.oid) as return_type,
  nullif(rt.typrelid, $10) as return_type_relation_id,
  f.proretset as is_set_returning_function,
  case
    when f.provolatile = $11 then $12
    when f.provolatile = $13 then $14
    when f.provolatile = $15 then $16
  end as behavior,
  f.prosecdef as security_definer,
  f_config.config_params as config_params
from
  functions f
  left join pg_namespace n on f.pronamespace = n.oid
  left join pg_language l on f.prolang = l.oid
  left join pg_type rt on rt.oid = f.prorettype
  left join (
    select
      oid,
      jsonb_object_agg(param, value) filter (where param is not null) as config_params
    from
      (
        select
          oid,
          (string_to_array(unnest(proconfig), $17))[$18] as param,
          (string_to_array(unnest(proconfig), $19))[$20] as value
        from
          functions
      ) as t
    group by
      oid
  ) f_config on f_config.oid = f.oid
  left join (
    select
      oid,
      jsonb_agg(jsonb_build_object(
        $21, t2.mode,
        $22, name,
        $23, type_id,
        -- Cast null into false boolean
        $24, COALESCE(has_default, $25)
      )) as args
    from
      (
        select
          oid,
          unnest(arg_modes) as mode,
          unnest(arg_names) as name,
          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume
          -- integer, we need to cast it to be properly parsed
          unnest(arg_types)::int8 as type_id,
          unnest(arg_has_defaults) as has_default
        from
          functions
      ) as t1,
      lateral (
        select
          case
            when t1.mode = $26 then $27
            when t1.mode = $28 then $29
            when t1.mode = $30 then $31
            when t1.mode = $32 then $33
            else $34
          end as mode
      ) as t2
    group by
      t1.oid
  ) f_args on f_args.oid = f.oid

    )
    select
      f.*
    from f
   where schema NOT IN ($35,$36,$37)

-- source: dashboard
-- user: d6424402-9faf-4699-a7d3-aef0745431cb
-- date: 2025-11-30T13:48:57.181Z",postgres,364,260.41900881044,182.443795,2470.479904,94792.519207,69161,100.0000000000000000,1.1120434807547839,null
SELECT name FROM pg_timezone_names,authenticator,127,509.170518897638,52.999872,1136.174456,64664.6559,151638,0,0.7586032065654412,"{""has_suggestion"":null,""startup_cost_before"":0,""startup_cost_after"":0,""total_cost_before"":10,""total_cost_after"":10,""index_statements"":[]}"
"with query_results as (
          select
              auth.rolname,
              statements.query,
              statements.calls,
              -- -- Postgres 13, 14, 15
              statements.total_exec_time + statements.total_plan_time as total_time,
              statements.min_exec_time + statements.min_plan_time as min_time,
              statements.max_exec_time + statements.max_plan_time as max_time,
              statements.mean_exec_time + statements.mean_plan_time as mean_time,
              -- -- Postgres <= 12
              -- total_time,
              -- min_time,
              -- max_time,
              -- mean_time,
              statements.rows / statements.calls as avg_rows,
              statements.rows as rows_read,
              statements.shared_blks_hit as debug_hit,
              statements.shared_blks_read as debug_read,
              case 
                when (statements.shared_blks_hit + statements.shared_blks_read) > $1 
                then (statements.shared_blks_hit::numeric * $2) / 
                     (statements.shared_blks_hit + statements.shared_blks_read)
                else $3
              end as cache_hit_rate,
              ((statements.total_exec_time + statements.total_plan_time)/sum(statements.total_exec_time + statements.total_plan_time) OVER()) * $4 as prop_total_time,
              case
                when (lower(statements.query) like $5 or lower(statements.query) like $6)
                then (
                  select json_build_object(
                    $7, array_length(index_statements, $8) > $9,
                    $10, startup_cost_before,
                    $11, startup_cost_after,
                    $12, total_cost_before,
                    $13, total_cost_after,
                    $14, index_statements
                  )
                  from index_advisor(statements.query)
                )
                else $15
              end as index_advisor_result
            from pg_stat_statements as statements
              inner join pg_authid as auth on statements.userid = auth.oid
            
          )
          select *
          from query_results
          
          order by total_time desc
          limit $16

-- source: dashboard
-- user: d6424402-9faf-4699-a7d3-aef0745431cb
-- date: 2025-11-30T11:02:25.980Z",postgres,4,3709.69854325,656.066667,9539.131659,14838.794173,80,99.9998718976000656,0.17407897226902871,null
"select
    schemaname, tablename, format($2, schemaname, tablename)::regclass as oid
    from pg_publication_tables where pubname = $1",supabase_admin,4451,3.32238488204898,0.334275,61.16903,14787.93511,69596,100.0000000000000000,0.17348232719703796,"{""has_suggestion"":null,""startup_cost_before"":55.53,""startup_cost_after"":55.53,""total_cost_before"":87.84,""total_cost_after"":87.84,""index_statements"":[]}"
"SELECT
    tbl.schemaname,
    tbl.tablename,
    tbl.quoted_name,
    tbl.is_table,
    json_agg(a) as columns
  FROM
    (
      SELECT
        n.nspname as schemaname,
        c.relname as tablename,
        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,
        $2 as is_table
      FROM
        pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
      WHERE
        c.relkind = $3
        AND n.nspname not in ($4, $5, $6)
        AND n.nspname not like $7
        AND n.nspname not like $8
        AND has_schema_privilege(n.oid, $9) = $10
        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13
      union all
      SELECT
        n.nspname as schemaname,
        c.relname as tablename,
        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,
        $15 as is_table
      FROM
        pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
      WHERE
        c.relkind in ($16, $17)
        AND n.nspname not in ($18, $19, $20)
        AND n.nspname not like $21
        AND n.nspname not like $22
        AND has_schema_privilege(n.oid, $23) = $24
        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27
    ) as tbl
    LEFT JOIN (
      SELECT
        attrelid,
        attname,
        format_type(atttypid, atttypmod) as data_type,
        attnum,
        attisdropped
      FROM
        pg_attribute
    ) as a ON (
      a.attrelid = tbl.quoted_name::regclass
      AND a.attnum > $28
      AND NOT a.attisdropped
      AND has_column_privilege(tbl.quoted_name, a.attname, $29)
    )
  
  GROUP BY schemaname, tablename, quoted_name, is_table",postgres,363,28.7586801597796,7.411529,137.692266,10439.400898,25816,99.9999447433216779,0.1224681842905306,"{""has_suggestion"":null,""startup_cost_before"":243.77,""startup_cost_after"":243.77,""total_cost_before"":244.87,""total_cost_after"":244.87,""index_statements"":[]}"
"WITH
-- Recursively get the base types of domains
base_types AS (
  WITH RECURSIVE
  recurse AS (
    SELECT
      oid,
      typbasetype,
      typnamespace AS base_namespace,
      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type
    FROM pg_type
    UNION
    SELECT
      t.oid,
      b.typbasetype,
      b.typnamespace AS base_namespace,
      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type
    FROM recurse t
    JOIN pg_type b ON t.typbasetype = b.oid
  )
  SELECT
    oid,
    base_namespace,
    base_type
  FROM recurse
  WHERE typbasetype = $5
),
arguments AS (
  SELECT
    oid,
    array_agg((
      COALESCE(name, $6), -- name
      type::regtype::text, -- type
      CASE type
        WHEN $7::regtype THEN $8
        WHEN $9::regtype THEN $10
        WHEN $11::regtype THEN $12
        WHEN $13::regtype THEN $14
        ELSE type::regtype::text
      END, -- convert types that ignore the length and accept any value till maximum size
      idx <= (pronargs - pronargdefaults), -- is_required
      COALESCE(mode = $15, $16) -- is_variadic
    ) ORDER BY idx) AS args,
    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments
      WHEN $17 THEN $18
      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)
      ELSE $26
    END AS callable
  FROM pg_proc,
       unnest(proargnames, proargtypes, proargmodes)
         WITH ORDINALITY AS _ (name, type, mode, idx)
  WHERE type IS NOT NULL -- only input arguments
  GROUP BY oid
)
SELECT
  pn.nspname AS proc_schema,
  p.proname AS proc_name,
  d.description AS proc_description,
  COALESCE(a.args, $27) AS args,
  tn.nspname AS schema,
  COALESCE(comp.relname, t.typname) AS name,
  p.proretset AS rettype_is_setof,
  (t.typtype = $28
   -- if any TABLE, INOUT or OUT arguments present, treat as composite
   or COALESCE(proargmodes::text[] && $29, $30)
  ) AS rettype_is_composite,
  bt.oid <> bt.base_type as rettype_is_composite_alias,
  p.provolatile,
  p.provariadic > $31 as hasvariadic,
  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,
  coalesce(func_settings.kvs, $36) as kvs
FROM pg_proc p
LEFT JOIN arguments a ON a.oid = p.oid
JOIN pg_namespace pn ON pn.oid = p.pronamespace
JOIN base_types bt ON bt.oid = p.prorettype
JOIN pg_type t ON t.oid = bt.base_type
JOIN pg_namespace tn ON tn.oid = t.typnamespace
LEFT JOIN pg_class comp ON comp.oid = t.typrelid
LEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass
LEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38
LEFT JOIN LATERAL (
  SELECT
    array_agg(row(
      substr(setting, $39, strpos(setting, $40) - $41),
      substr(setting, strpos(setting, $42) + $43)
    )) as kvs
  FROM unnest(proconfig) setting
  WHERE setting ~ ANY($2)
) func_settings ON $44
WHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)
AND prokind = $47
AND p.pronamespace = ANY($1::regnamespace[])",authenticator,127,54.0836037165354,23.052462,230.734368,6868.617672,733,99.9568931867475400,0.08057810434666299,null
"WITH
-- Recursively get the base types of domains
base_types AS (
  WITH RECURSIVE
  recurse AS (
    SELECT
      oid,
      typbasetype,
      typnamespace AS base_namespace,
      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type
    FROM pg_type
    UNION
    SELECT
      t.oid,
      b.typbasetype,
      b.typnamespace AS base_namespace,
      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type
    FROM recurse t
    JOIN pg_type b ON t.typbasetype = b.oid
  )
  SELECT
    oid,
    base_namespace,
    base_type
  FROM recurse
  WHERE typbasetype = $4
),
columns AS (
    SELECT
        c.oid AS relid,
        a.attname::name AS column_name,
        d.description AS description,
        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column
        CASE
          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)
          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)
          WHEN a.attgenerated = $9 THEN $10
          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text
        END AS column_default,
        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,
        CASE
            WHEN t.typtype = $12 THEN
            CASE
                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)
                ELSE format_type(a.atttypid, a.atttypmod)
            END
            ELSE
            CASE
                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)
                ELSE format_type(a.atttypid, a.atttypmod)
            END
        END::text AS data_type,
        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,
        information_schema._pg_char_max_length(
            information_schema._pg_truetypid(a.*, t.*),
            information_schema._pg_truetypmod(a.*, t.*)
        )::integer AS character_maximum_length,
        bt.base_type,
        a.attnum::integer AS position
    FROM pg_attribute a
        LEFT JOIN pg_description AS d
            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass
        LEFT JOIN pg_attrdef ad
            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
        JOIN pg_class c
            ON a.attrelid = c.oid
        JOIN pg_type t
            ON a.atttypid = t.oid
        LEFT JOIN base_types bt
            ON t.oid = bt.oid
        LEFT JOIN pg_depend seq
            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18
    WHERE
        NOT pg_is_other_temp_schema(c.relnamespace)
        AND a.attnum > $19
        AND NOT a.attisdropped
        AND c.relkind in ($20, $21, $22, $23, $24)
        AND c.relnamespace = ANY($1::regnamespace[])
),
columns_agg AS (
  SELECT
    relid,
    array_agg(row(
      column_name,
      description,
      is_nullable::boolean,
      data_type,
      nominal_data_type,
      character_maximum_length,
      column_default,
      coalesce(
        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),
        $25
      )
    ) order by position) as columns
  FROM columns
  GROUP BY relid
),
tbl_pk_cols AS (
  SELECT
    r.oid AS relid,
    array_agg(a.attname ORDER BY a.attname) AS pk_cols
  FROM pg_class r
  JOIN pg_constraint c
    ON r.oid = c.conrelid
  JOIN pg_attribute a
    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)
  WHERE
    c.contype in ($26)
    AND r.relkind IN ($27, $28)
    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)
    AND NOT pg_is_other_temp_schema(r.relnamespace)
    AND NOT a.attisdropped
  GROUP BY r.oid
)
SELECT
  n.nspname AS table_schema,
  c.relname AS table_name,
  d.description AS table_description,
  c.relkind IN ($31,$32) as is_view,
  (
    c.relkind IN ($33,$34)
    OR (
      c.relkind in ($35,$36)
      -- The function `pg_relation_is_updateable` returns a bitmask where 8
      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.
      -- it's possible to insert into the relation.
      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39
    )
  ) AS insertable,
  (
    c.relkind IN ($40,$41)
    OR (
      c.relkind in ($42,$43)
      -- CMD_UPDATE
      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46
    )
  ) AS updatable,
  (
    c.relkind IN ($47,$48)
    OR (
      c.relkind in ($49,$50)
      -- CMD_DELETE
      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53
    )
  ) AS deletable,
  coalesce(tpks.pk_cols, $54) as pk_cols,
  coalesce(cols_agg.columns, $55) as columns
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
LEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass
LEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid
LEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid
WHERE c.relkind IN ($58,$59,$60,$61,$62)
AND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)
AND not c.relispartition
ORDER BY table_schema, table_name",authenticator,127,46.8062789055118,7.024882,296.342415,5944.397421,8069,99.9281266177793638,0.06973576031462247,null
"SELECT t.oid, t.typname, t.typsend, t.typreceive, t.typoutput, t.typinput,
       coalesce(d.typelem, t.typelem), coalesce(r.rngsubtype, $1), ARRAY (
  SELECT a.atttypid
  FROM pg_attribute AS a
  WHERE a.attrelid = t.typrelid AND a.attnum > $2 AND NOT a.attisdropped
  ORDER BY a.attnum
)

FROM pg_type AS t
LEFT JOIN pg_type AS d ON t.typbasetype = d.oid
LEFT JOIN pg_range AS r ON r.rngtypid = t.oid OR r.rngmultitypid = t.oid OR (t.typbasetype <> $3 AND r.rngtypid = t.typbasetype)
WHERE (t.typrelid = $4)
AND (t.typelem = $5 OR NOT EXISTS (SELECT $6 FROM pg_catalog.pg_type s WHERE s.typrelid != $7 AND s.oid = t.typelem))",supabase_admin,83,67.1886178313253,4.797683,127.582113,5576.65528,18263,99.9995410338671109,0.06542165141743371,"{""has_suggestion"":null,""startup_cost_before"":0.28,""startup_cost_after"":0.28,""total_cost_before"":2133.6,""total_cost_after"":2133.6,""index_statements"":[]}"
"select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",authenticated,31774,0.157628200352489,0.019381,228.394266,5008.47843799999,31774,100.0000000000000000,0.05875617445419152,"{""has_suggestion"":null,""startup_cost_before"":0,""startup_cost_after"":0,""total_cost_before"":0.03,""total_cost_after"":0.03,""index_statements"":[]}"
"SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",supabase_admin,24,197.033701958333,109.182863,566.827504,4728.808847,24,0,0.05547527477942131,"{""has_suggestion"":null,""startup_cost_before"":null,""startup_cost_after"":null,""total_cost_before"":null,""total_cost_after"":null,""index_statements"":[]}"
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,4659.300412,4659.300412,4659.300412,4659.300412,1,100.0000000000000000,0.05465984754269575,null
"CREATE TYPE pg_temp.tabledefs AS ENUM('PKEY_INTERNAL','PKEY_EXTERNAL','FKEYS_INTERNAL','FKEYS_EXTERNAL','COMMENTS','FKEYS_NONE','INCLUDE_TRIGGERS','NO_TRIGGERS')",postgres,390,10.5159592923077,0.980587,63.928963,4101.224124,0,99.9952706601212603,0.04811286363483058,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,3459.299842,3459.299842,3459.299842,3459.299842,1,100.0000000000000000,0.04058223021662324,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,3015.282115,3015.282115,3015.282115,3015.282115,1,100.0000000000000000,0.03537330631861331,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,3003.948234,3003.948234,3003.948234,3003.948234,1,100.0000000000000000,0.03524034468215572,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,2978.724641,2978.724641,2978.724641,2978.724641,1,100.0000000000000000,0.03494443808117585,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,2972.862284,2972.862284,2972.862284,2972.862284,1,100.0000000000000000,0.03487566476511416,null